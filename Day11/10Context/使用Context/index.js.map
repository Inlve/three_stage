{"version":3,"sources":["index.jsx"],"names":["ThemeContext","React","createContext","App","Component","Toolbar","ThemedButton","context","Button","props","theme","ReactDOM","render","document","getElementById"],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA,IAAMA,YAAY,GAAGC,KAAK,CAACC,aAAN,CAAoB,OAApB,CAArB;;IAEMC,G;;;;;;;;;;;;;6BACQ;AACN;AACA;AACA;AACA,aACI,oBAAC,YAAD,CAAc,QAAd;AAAuB,QAAA,KAAK,EAAG;AAA/B,SACI,oBAAC,OAAD;AAAS,QAAA,KAAK,EAAG;AAAjB,QADJ,CADJ;AAKH;;;;EAVaF,KAAK,CAACG,S;;IAalBC,O;;;;;;;;;;;;;6BACQ;AACN;AACA;AACA;AACA;AAEA;AACA;AACA;AACA,aACI,iCACI,oBAAC,YAAD,OADJ,CADJ;AAKH;;;;EAfiBJ,KAAK,CAACG,S;;IAkBtBE,Y;;;;;;;;;;;;;AACF;AACA;6BAGU;AACN,aACI,oBAAC,MAAD;AAAQ,QAAA,KAAK,EAAI,KAAKC;AAAtB,QADJ;AAGH;;;;EATsBN,KAAK,CAACG,S;;gBAA3BE,Y,iBAGmBN,Y;;IASnBQ,M;;;;;;;;;;;;;6BACQ;AACN,aACI,iCAAM,KAAKC,KAAL,CAAWC,KAAjB,CADJ;AAGH;;;;EALgBT,KAAK,CAACG,S;;AAQ3BO,QAAQ,CAACC,MAAT,CACI,oBAAC,GAAD,OADJ,EAEIC,QAAQ,CAACC,cAAT,CAAwB,MAAxB,CAFJ;AAKA","sourcesContent":["// Context可以让我们无需明确地传递给每一个组件,就能将值传递深入到每一个组件\r\n// 为当前的theme创建一个context,light为默认值\r\nconst ThemeContext = React.createContext('light');\r\n\r\nclass App extends React.Component {\r\n    render () {\r\n        // 使用Provider来讲当前的theme传递给以下的组件树.\r\n        // 无论多深,任何组件都能够读取这个值\r\n        // 在这个例子中,我们将\"dark\"作为当前的值传递下去\r\n        return (\r\n            <ThemeContext.Provider value = \"dark\">\r\n                <Toolbar theme = \"dark\" />\r\n            </ThemeContext.Provider>\r\n        );\r\n    }\r\n}\r\n\r\nclass Toolbar extends React.Component {\r\n    render () {\r\n        // Toolbar组件接受一个额外的\"theme\"属性,然后传递给ThemedButton组件.\r\n        // 如果应用中每一个单独的但牛都需要知道theme的值,这样会很麻烦\r\n        // 因为必须将这个值层层的传递给所有的组件\r\n        // 而使用了Context就可以避免中间元素传递props\r\n\r\n        //  使用了Context之后,不需要像这样:\r\n        // <ThemedButton theme={this.props.theme} />\r\n        // 来指定往下传递theme了\r\n        return (\r\n            <div>\r\n                <ThemedButton />\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nclass ThemedButton extends React.Component {\r\n    // 指定contextType 读取当前的Theme context\r\n    // React会往上找到最近的theme Provider,然后使用他的值\r\n    static contextType = ThemeContext;\r\n\r\n    render () {\r\n        return (\r\n            <Button theme = {this.context} />\r\n        );\r\n    }\r\n}\r\n\r\nclass Button extends React.Component {\r\n    render () {\r\n        return (\r\n            <div>{this.props.theme}</div>\r\n        )\r\n    }\r\n}\r\n\r\nReactDOM.render(\r\n    <App />,\r\n    document.getElementById('root')\r\n);\r\n\r\n/**\r\n * 一般来说需要谨慎使用Context\r\n * 使用的步骤是:\r\n * 1. React.createContext();生成一个Context对象\r\n * 2. Context.Provider;订阅Context变化\r\n * 3. 挂在Class.contextType,使用this.context来读取最近的Context对象上的那个值\r\n *\r\n * const MyContext = React.createContext(defaultValue); // defaultValue 一个默认值\r\n * <MyContext.Provider value = { 某一个值 } />\r\n * class MyClass extends React.Component{\r\n *     componentDidMount(){\r\n *         ket value = this.context;\r\n *     }\r\n *     // 或者使用\r\n *     static contextType = MyContext\r\n * }\r\n */"],"file":"index.js"}